<html dir='ltr' lang='en'>

<head>
  <meta charset='utf-8' />
  <meta name='viewport' content='width=device-width, initial-scale=1.0, interactive-widget=resizes-visual' />
  <title>Spud life TEST 3</title>
  <style>
    .container {
      display: grid;
      width: 100%;
      height: 100%;
      outline: 1px solid red;
    }

    .sprite {
      position: absolute;
      outline: 1px solid red;
      background: wheat;
    }

    .player {
      background-color: white;
    }

    .control {
      background-color: cornflowerblue;
      color: white;
    }
  </style>
  <script>

    let itemNumber = 0;
    let qty = 10;
    let sprite = { width: 50, height: 50, buffer: { x: 5, y: 5 } };
    let containerBox = null;
    let playerId = 0;
    let step = { x: 5, y: 5 };
    let grid = { x: 10, y: 10 };
    let playerBuffer = { x: 10, y: 5 };

    // what is this!?! 
    let scale = 5;
    let timers = { duration: 30 };


    document.addEventListener("DOMContentLoaded", function () {
      setContainerBox();
      //addSprites();
      addRandom();
      addPlayer();
      addControls();
    });

    function setContainerBox() {
      let containerElement = document.querySelector(".container");
      containerBox = containerElement.getBoundingClientRect();
      setSpriteSize();
    }

    function addControls() {
      const directions = ['left', 'down', 'up', 'right'];
      const positions = [
        [1, containerBox.height - (sprite.height * 5)],
        [sprite.width, containerBox.height - (sprite.height * 5)],
        [sprite.width, containerBox.height - (sprite.height * 6)],
        [(sprite.width * 2), containerBox.height - (sprite.height * 5)]
      ];
      const moveFunctions = [moveLeft, moveDown, moveUp, moveRight];
      const timerKeys = ['moveLeft', 'moveDown', 'moveUp', 'moveRight'];

      directions.forEach((direction, index) => {
        let [x, y] = positions[index];
        let controlId = addSprite(x, y, '', sprite.width, sprite.height, 'control');
        let controlElement = document.querySelector(`#i${controlId}`);
        controlElement.onmousedown = moveFunctions[index];
        controlElement.onmouseup = function () {
          clearInterval(timers[timerKeys[index]]);
          timers.moving = false;
        };
        controlElement.addEventListener("touchstart", moveFunctions[index], false);
        controlElement.addEventListener("touchend", function () {
          clearInterval(timers[timerKeys[index]]);
          timers.moving = false;
        }, false);
      });
    }

    function addPlayer() {
      playerId = addSprite(1, 1, 'P', sprite.width, sprite.height, 'player');
    }

    function getPlayerSprite() {
      return document.querySelector(`#i${playerId}`);
    }

    function clearBody() {
      let bodyElement = document.querySelector("body");
      bodyElement.innerHTML = '<div class="container"></dv>';
    }

    function addRandom() {
      clearBody();
      for (let step = 0; step < qty; step++) {
        let x = rnd(containerBox.width - sprite.width);
        let y = rnd(containerBox.height - sprite.height);
        addSprite(x, y, ``, sprite.width, sprite.height, 'block');
      }
    }

    // adds a grid with no overlaps
    function addSprites() {
      clearBody();
      let step = { x: 0, y: 0 };
      for (step.y = 0; step.y < grid.y; step.y++) {
        let y = sprite.height * step.y;
        for (step.x = 0; step.x < grid.x; step.x++) {
          let x = sprite.width * step.x;
          addSprite(x, y, ``, sprite.width, sprite.height);
        }
      }
    }

    window.addEventListener("resize", (event) => {
      let last = {
        width: containerBox.width,
        height: containerBox.height
      }
      setContainerBox();
      //
      let newWidthPct = (containerBox.width - last.width) / 100;
      let newHeightPct = (containerBox.height - last.height) / 100;

      console.log(last, newWidthPct, newHeightPct);

      resizeSprites(newWidthPct, newHeightPct);
    });

    function resizeSprites(newWidthPct, newHeightPct) {
      let spritesList = document.querySelectorAll('.block');
      spritesList.forEach(element => {
        let elementBox = element.getBoundingClientRect();
        let newLeft = elementBox.left + ((elementBox.left * newWidthPct) / scale);
        let newTop = elementBox.top + ((elementBox.top * newHeightPct) / scale);

        element.style.left = `${newLeft}px`;
        element.style.top = `${newTop}px`;
        element.style.width = `${sprite.width}px`;
        element.style.height = `${sprite.height}px`
      });
    }

    function setSpriteSize() {
      sprite.width = containerBox.width / 10;
      sprite.height = containerBox.height / 10;
      // make sure its square..
      if (sprite.height > sprite.width) {
        sprite.height = sprite.width;
      } else {
        sprite.width = sprite.height;
      }
      grid.x = parseInt(containerBox.width / sprite.width);
      grid.y = parseInt(containerBox.height / sprite.height);
    }

    function rnd(max) {
      return Math.floor(Math.random() * max);
    }

    document.addEventListener("keydown", (event) => {
      switch (event.code) {
        case 'ArrowUp':
          moveUp();
          break;
        case 'ArrowDown':
          moveDown();
          break;
        case 'ArrowLeft':
          moveLeft();
          break;
        case 'ArrowRight':
          moveRight();
          break;
      }
    });

    document.addEventListener("keyup", (event) => {
      switch (event.code) {
        case 'ArrowUp':
          clearInterval(timers.moveUp);
          timers.moving = false;
          break;
        case 'ArrowDown':
          clearInterval(timers.moveDown);
          timers.moving = false;
          break;
        case 'ArrowLeft':
          clearInterval(timers.moveLeft);
          timers.moving = false;
          break;
        case 'ArrowRight':
          clearInterval(timers.moveRight);
          timers.moving = false;
          break;
      }
    });

    function moveUp() {
      if (!timers.moving) {
        timers.moveUp = setInterval(() => {
          let playerSprite = getPlayerSprite();
          let playerBox = playerSprite.getBoundingClientRect();
          let newTop = playerBox.top - step.y;
          if (newTop > 0 && collision('up') != true) {
            playerSprite.style.top = `${newTop}px`;
          }
          timers.moving = true;
        }, timers.duration);
      }
    }

    function moveDown() {
      if (!timers.moving) {
        timers.moveDown = setInterval(() => {
          let playerSprite = getPlayerSprite();
          let playerBox = playerSprite.getBoundingClientRect();
          let newTop = playerBox.top + step.y;
          if (newTop < containerBox.height - sprite.height && collision('down') != true) {
            playerSprite.style.top = `${newTop}px`;
          }
          timers.moving = true;
        }, timers.duration);
      }
    }

    function moveLeft() {
      if (!timers.moving) {
        timers.moveLeft = setInterval(() => {
          let playerSprite = getPlayerSprite();
          let playerBox = playerSprite.getBoundingClientRect();
          let newLeft = playerBox.left - step.x;
          if (newLeft > 0 && collision('left') != true) {
            playerSprite.style.left = `${newLeft}px`;
          }
          timers.moving = true;
        }, timers.duration);
      }
    }

    function moveRight() {
      if (!timers.moving) {
        timers.moveRight = setInterval(() => {
          let playerSprite = getPlayerSprite();
          let playerBox = playerSprite.getBoundingClientRect();
          let newLeft = playerBox.left + step.x;
          if (newLeft < containerBox.width - sprite.width && collision('right') != true) {
            playerSprite.style.left = `${newLeft}px`;
          }
          timers.moving = true;
        }, timers.duration);
      }
    }

    function collision(direction) {
      let retValue = false;
      let playerSprite = getPlayerSprite();
      let playerBox = playerSprite.getBoundingClientRect();
      let playerCorner = {
        x: playerBox.left + playerBuffer.x,
        y: playerBox.top + playerBuffer.y,
      };
      if (direction === 'right') {
        playerCorner.x += playerBox.width - playerBuffer.x;
      } else if (direction === 'left') {
        playerCorner.x += playerBuffer.x;
      }
      if (direction === 'down') {
        playerCorner.y += playerBox.height - playerBuffer.y;
      } else if (direction === 'up') {
        playerCorner.y += playerBuffer.x;
      }
      let spritesList = document.querySelectorAll('.block');
      spritesList.forEach(element => {
        if (!retValue) {
          let spriteBox = element.getBoundingClientRect();
          let checkCorner = {
            x: spriteBox.left + sprite.buffer.x,
            y: spriteBox.top + sprite.buffer.y,
          };
          if (direction === 'right') {
            checkCorner.x += sprite.buffer.x;
          } else if (direction === 'left') {
            checkCorner.x += spriteBox.width + sprite.buffer.x;
          } else if (direction === 'up') {
            checkCorner.y += spriteBox.height + sprite.buffer.y;
          }
          if (direction === 'right' || direction === 'left') {
            if ((playerCorner.x >= checkCorner.x && direction === 'left') || (playerCorner.x <= checkCorner.x && direction === 'right')) {
              if ((playerCorner.x < checkCorner.x + sprite.buffer.x && direction === 'left') || ((playerCorner.x + playerBuffer.x) > checkCorner.x && direction === 'right')) {
                // our X means we are potential collision..
                if ((playerCorner.y + playerBox.height - playerBuffer.y) > checkCorner.y) {
                  if ((playerCorner.y + playerBuffer.y) <= (checkCorner.y + spriteBox.height)) {
                    retValue = true;
                  }
                }
              }
            }
          } else if (direction === 'up' || direction === 'down') {
            if ((playerCorner.y >= checkCorner.y && direction === 'up') || (playerCorner.y <= checkCorner.y && direction === 'down')) {
              if ((playerCorner.y < checkCorner.y + sprite.buffer.y && direction === 'up') || ((playerCorner.y + playerBuffer.y) > checkCorner.y && direction === 'down')) {
                // our Y means we are potential collision..
                if ((playerCorner.x + playerBox.width - playerBuffer.x) > checkCorner.x) {
                  if ((playerCorner.x + playerBuffer.x) <= (checkCorner.x + spriteBox.width)) {
                    retValue = true;
                  }
                }
              }
            }
          }
        }
      });

      return retValue;
    }

    // assume we are moving right.. we return true if something is directly on our right border
    function collisionRight() {
      let retValue = false;
      let buffer = 10; // 5 pixel buffer
      let playerSprite = getPlayerSprite();
      let playerBox = playerSprite.getBoundingClientRect();
      let playerCorner = {
        x: playerBox.left + playerBox.width - playerBuffer.x,
        y: playerBox.top + playerBuffer.y,
      };
      let spritesList = document.querySelectorAll('.sprite');
      spritesList.forEach(element => {
        if (!retValue) {
          let spriteBox = element.getBoundingClientRect();
          let checkCorner = {
            x: spriteBox.left + sprite.buffer.x,
            y: spriteBox.top + sprite.buffer.y,
          };
          if (playerCorner.x <= checkCorner.x) {
            if ((playerCorner.x + playerBuffer.x) > checkCorner.x) {
              // our X means we are potential collision..
              if ((playerCorner.y + playerBox.height - playerBuffer.y) > checkCorner.y) {
                if ((playerCorner.y + playerBuffer.y) <= (checkCorner.y + spriteBox.height)) {
                  retValue = true;
                }
              }
            }
          }
        }
      });

      return retValue;
    }

    function collisionLeft() {
      let retValue = false;
      let buffer = 10; // 5 pixel buffer
      let playerSprite = getPlayerSprite();
      let playerBox = playerSprite.getBoundingClientRect();
      let playerCorner = {
        x: playerBox.left + playerBuffer.x,
        y: playerBox.top + playerBuffer.y,
      };
      let spritesList = document.querySelectorAll('.sprite');
      spritesList.forEach(element => {
        if (!retValue) {
          let spriteBox = element.getBoundingClientRect();
          let checkCorner = {
            x: spriteBox.left + spriteBox.width + sprite.buffer.x,
            y: spriteBox.top + sprite.buffer.y,
          };
          if (playerCorner.x >= checkCorner.x) {
            if (playerCorner.x < checkCorner.x + sprite.buffer.x) {
              // our X means we are potential collision..
              if ((playerCorner.y + playerBox.height - playerBuffer.y) > checkCorner.y) {
                if ((playerCorner.y + playerBuffer.y) <= (checkCorner.y + spriteBox.height)) {
                  retValue = true;
                }
              }
            }
          }
        }
      });

      return retValue;
    }

    function addSprite(x, y, content, w, h, classList = '') {
      itemNumber++;
      let width = `${w}px`;
      let height = `${h}px`;
      let top = `${y}px`;
      let left = `${x}px`;
      let style = `width: ${width}; height:${height}; top:${top}; left:${left};`;
      let newSprite = `<div id="i${itemNumber}" class="sprite ${classList}" style="${style}">${content}</div>`;
      let bodyElement = document.querySelector("body");
      bodyElement.insertAdjacentHTML('beforeend', newSprite);
      return itemNumber;
    }

  </script>
</head>

<body style="margin: 0">
  <div class="container"></div>
</body>

</html>